---
layout:     blogpost
title:      "Работа с большими проектами в Max/MSP"
date:       2014-04-15 02:08:00
categories: blog
author:     "OSCII"
permalink:  /managing-big-projects-in-maxmsp.html

---

<p>Давненько я уже не писал оригинального материала на <em>pattr</em>. Всегда
    было либо лень писать статьи о том, как «просто и непринужденно сделать нечто
    в Max/MSP», либо просто лень, либо не было идей, времени и т.д. Однако, все
    это время в голове зрела тема для статьи. Хотелось написать нечто более
    интересное, основанное на собственном опыте, чего нет в туториалах к максу.
</p>
<p>
В конце марта на новой сцене Александринского театра состоялась
    премьера медиаспектакля «Нейроинтегрум», в работе над которым я принимал
    участие. В мои задачи входило программирование элементов интеракции
    компьютера и перформера, работа с многоканальным аудио и некоторые другие
    задачи, связанные с управлением компьютерами, генерирующих графику.
    Все это вылилось в довольно большой патч: 115 файлов <em>.maxpat</em>,
    207 коммитов на BitBucket, несколько Java-классов, написанных
    для специфичных целей, — все в целом (вместе с аудиофайлами) занимает
    571 Мб. Думаю, материала из полученного опыта хватит на несколько статей.
</p>
<p>
Кое-что о технической стороне «Нейроинтегрума» можно узнать из
    <a target="_blank" href="http://habrahabr.ru/post/217565/">статьи</a>
    на хабре, которую я писал недавно, а здесь же я расскажу о некоторых
    особенностях работы с большими проектами в Max/MSP. Детальный
    разбор примененных технологий оставлю на следующий раз. Тех,
    кто заинтересовался, прошу под кат.</p>


<!-- ########################## -->
<!-- ### Project structure #### -->
<!-- ########################## -->


<h2>Организация проекта</h2>

<p>В начале работы над «Нейроинтегрумом» я принял решение создать отдельный
    <a href="http://cycling74.com/2013/03/11/max-6-feature-packages/"
       target="_blank">package</a> для всех файлов проекта. Кто еще не знает,
       пэкэджи — это убер-удобная фича для организации
    библиотек, добавленная в шестой версии. Пэкэдж определяет структуру директорий,
    в которых должны располагаться патчи, хелпы, экстерналы, Java-классы и т.д.
    Организовав один раз свою библиотечку в таких директориях, ею можно легко
    делиться с другими — никому больше не придется вручную копировать файлы в папки
    <strong>Cycling '74/</strong>, <strong>patchers/extras</strong>, etc...
    ну вы поняли.</p>

<p>Папка с проектом на текущий момент выглядит так: <br />
<code>
	<span>
		&nbsp;&nbsp;&nbsp;&nbsp;neurointegrum-maxmsp/ <br />
		&nbsp;&nbsp;&nbsp;&nbsp;├── java-classes <br />
		&nbsp;&nbsp;&nbsp;&nbsp;├── jsui <br />
		&nbsp;&nbsp;&nbsp;&nbsp;├── media <br />
		&nbsp;&nbsp;&nbsp;&nbsp;├── misc <br />
		&nbsp;&nbsp;&nbsp;&nbsp;└── patchers <br />
	</span>
</code></p>

<p>Названия папок говорят сами за себя. Можно лишь отметить, что в директории
    <em>misc</em> у меня лежат файлы с патчами, созданными специально для того,
    чтобы изолированно тестировать работу отдельных синтезаторов. Хотя,
    по-хорошему, такие патчи должны быть хелпами — но ладно, в следующий раз
    сделаю иначе.</p>

<p>В папке <em>patchers</em> у меня лежат все патчи. Среди них пять — особенные,
	они служат для запуска всего и вся: <em>+cuescripts.maxpat, +mappings.maxpat,
    +scenes.maxpat, +sound.maxpat, +sur.controller.maxpat.</em> Из названий
    можно догадаться, что в <em>+sound</em> находятся синтезаторы,
    а в <em>+mappings</em> — мэппинги для управления синтами.
    В <em>+sur.controller</em> располагается логика для управления
    многоканальным звуком; все синтезаторы так или иначе направляют звук в него.
    <em>+scenes</em> отвечает за управление параметрами в софте,
    генерирующем графику, который запущен на других компьютерах.
    Про <em>+cuescripts</em> поясню позже.
    Все эти патчи, запущенные и аккуратно расставленные, можно увидеть
    на следующем скриншоте:
</p>


<p><a href="/img/big-projects/1.png" target="_blank">
	<img src="/img/big-projects/1.png" />
</a></p>

<p>Собственно, «Нейроинтегрум» целиком и полностью управлялся из этих патчей.</p>

<p>В шестом максе также имеется возможность создания
    <a target="-_blank"
       href="http://cycling74.com/2012/12/03/max-6-feature-video-projects/">
        projects</a>. Это довольно удобный способ организации проектов,
    однако, у меня были две неудачные попытки перевести старые
    патчи средней сложности в этот формат, поэтому при работе над спектаклем
    решил использовать <em>package</em>. В будущем обязательно разберусь с этим,
    если не будет лень :)</p>

<p>Чтобы не взрывать вам мозг большим количеством технической инфы о том, как я
юзаю систему контроля версий с проектами Max/MSP, расскажу в конце статьи.</p>


<!-- ########################## -->
<!-- ####### Patch ctl ######## -->
<!-- ########################## -->


<h2>Управление патчем</h2>

<p>Max отлично подходит для создания небольших скетчей, проверки своих идей,
но когда патч разрастается, работа превращается в ужас: бесконечное количество
субпатчей, объектов send/receive непонятного назначения, бессмысленные комменты,
сделанные бессонной ночью и так далее. А всем этим нужно еще и управлять,
переключать состояние, добавлять новые фичи, тюнить алгоритмы... Мозг в какой-то
момент просто теряет способность удерживать все связи. Для того, чтобы немного разгрузить
голову, можно внести некоторую структуру в свою работу с Max.
</p>

<p>Одним из основных принципов разработки хорошего ПО является уменьшение
связности между компонентами системы. При небольшой связности очень легко
вносить изменения и добавлять новые фичи в софт, — вероятность
сломать что-то мала.</p>

<p>Но Max очень высокоуровневый и нисколько не объектно-ориентированный, что бы
не говорили про него не-программисты; большинство паттернов к нему просто
неприменимы, либо применимы, но инструменты весьма трудны в освоении. В качестве
такого примера можно взять библиотеку
<a href="http://cnmat.berkeley.edu/system/files/attachments/102_FREED_ADRIAN_PAPER_CR.pdf"
target="_blank"> odot</a> от CNMAT, авторы которой попытались привнести элементы
ООП и других парадигм в Max/MSP посредством хитрого использования OSC-сообщений (!).</p>


<h3>Jamoma</h3>

<p>Но не все так плохо. В Max коммьюнити не раз задумывались над тем, как
повысить продуктивность при работе с большими патчами. Одним из инструментов,
решающих эту проблему, является фреймворк
<a href="http://jamoma.org/" target="_blank">Jamoma</a>. При первом знакомстве
с ним мне казалось, что это просто набор объектов и различных хелперов.
Это не так. Jamoma — это, в первую очередь, набор инструментов и правил для
создания патчей. Он представляет из себя реализацию паттерна проектирования Model-View-Controller.
Я не буду детально рассказывать о нем (интересующихся просьба воспользоваться
<a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller"
target="_blank">wiki</a>), скажу лишь, что его суть заключается в разделении
бизнес-логики (например, алгоритмов синтеза), UI и части управления софтом.</p>

<p>Благодаря такому подходу, в патче «Нейроинтегрума» я могу спокойно создать
новый синтезатор в одном месте, создать для него мэппинги в другом
и управлять всем из третьего, не опасаясь сломать что-то.</p>

<p>Описание работы Jamoma само по себе тянет на несколько статей, поэтому
в данной я лишь кратко опишу, как работаю с этим фреймворком.</p>

<h4>Модули</h4>

<p>Jamoma предполагает, что патч организуется из модулей. Модуль представляет
из себя сделанный особым образом bpatcher, в котором инкапсулированы логика и UI.
В идеале, этот модуль не должен иметь никаких прямых связей
с другими модулями или частями патчей, однако, на практике, в том числе
в связи с некоторыми особенностями работы Max, это не всегда удается соблюсти.</p>

<p>На скриншоте представлены внутренности модуля, управляющего зрительским освещением
и стробоскопом в «Нейроинтегруме» по MIDI:</p>

<p><a href="/img/big-projects/2.png" target="_blank">
	<img src="/img/big-projects/2.png" />
</a></p>

<p>Слева вверху внешний вид модуля, справа внутренности bpatcher с UI, а слева
внизу логика модуля. Обратите внимание, что UI-объекты не соединяются напрямую
с логикой. Все изменения параметров поступают в объекты
<em>jcom.hub</em> и предпоследний аутлет <em>jcom.in</em>, который соединен
с алгоритмом, где и производится вся работа.</p>

<p>Каждый элемент UI имеет собственное имя, указываемое в первом аргументе
объектов <em>jcom.parameter, jcom.message</em> или <em>jcom.return.</em>
Любое изменение параметра приводит к передаче OSC-сообщения
в <em>jcom.hub</em> и <em>jcom.in</em>. Например, если включить на <em>toggle</em>,
то придет сообщение <code>/light 1</code>, если нажать на <em>button</em>,
то <code>/strobe</code>. В абстракции или субпатче с алгоритмом эти сообщения
разделяются посредством <em>jcom.oscroute</em>.

<p>Так происходит разделение логики и UI в Jamoma.</p>

<p>Каждый модуль в Jamoma имеет уникальное имя, по которому можно обратиться
к данному модулю из любой части патча (в нашем примере это
<code>/test_midi</code>). Включить зрительский свет можно, отправив сообщение
<code>/test_midi/light 1</code> в объект <em>[jcom.send jcom.remote.module.to]</em>.
Это включит <em>toggle</em> и отправит необходимые сообщения
в&nbsp;<em>jcom.hub</em> и&nbsp;<em>jcom.in</em>:</p>

<p><a href="/img/big-projects/3.png" target="_blank">
	<img src="/img/big-projects/3.png" />
</a></p>

<p>Для того, чтобы изменить параметр какого-либо модуля достаточно лишь вспомнить
его название и название параметра. Лично для меня это легче, чем вспомнить имя
объекта <em>receive</em>.</p>

<p>Такой подход, когда имеется доступ ко всем параметрам модуля,
позволяет легко описать состояние последнего с помощью последовательности
OSC-сообщений. Чуть ниже мы увидим пример того, как это используется.</p>

<p>Кроме удаленного управления параметрами модулей, Jamoma также позволяет следить
за изменениями параметров посредством объекта
<em>[jcom.receive jcom.remote.module.from]</em> — эту фичу удобно использовать
для создания мэппингов между контроллерами и синтами. Мэппинг можно поместить
в отдельный субпатч, напрямую не связанный с другими частями патча, что (по моим
личным ощущениям) очень сильно помогает производить поиск необходимого мэппинга,
когда требуется его доработка, а также позволяет не загружать голову тем, откуда
приходят те или иные сообщения.</p>


<h4>CUE скрипты</h4>

<p>И так, описав возможности по управлению модулями, мы подошли к одной из самых
замечательных фишек в Jamoma — CUE-скрипты. Скрипт — это текстовый файл, который
логически разбит на части, каждая из которых содержит набор OSC-сообщений,
отправляемых в модули. В ходе работы патча можно переключаться между этими частями,
тем самым меняя состояние всего патча.
В контексте перформансов, такой скрипт позволяет мыслить об управлении патчем, как
о переключении сцен: в разных сценах активируются разные синтезаторы, мэппинги,
производятся какие-то действия и т.д. Для переключения по скрипту я сделал
отдельный патч <em>+cuescripts</em>, окно которого всегда находится поверх остальных,
чтобы можно было легко определить, на каком этапе находится спектакль.</p>


<h4>И последнее о Jamoma</h4>

<p>Прелесть Jamoma лично для меня заключается в том,
что при условии работы «по ее правилам», можно добиться удивительной гибкости
при работе с большим проектом. Как показала практика, действительно легко вносить
изменения и добавлять фичи в уже разросшийся патч — из-за малого количества
прямых связей между модулями можно не думать о том, что может что-то сломаться
после внесенных изменений.</p>

<p>В Jamoma есть множество других прелестей (чего стоит только «упаковывание» нескольких
аудио сигналов в один патчкорд посредством <em>jcom.pack≈</em>). Тем, кто заинтересовался,
рекомендую ознакомиться с материалами на официальном
<a href="http://jamoma.org/" target="_blank">сайте</a>.</p>


<!-- ########################## -->
<!-- ######## Advices ######### -->
<!-- ########################## -->

<h2>Советы и прочее</h2>

<p>О самом главном инструменте при работе с большими патчами (лично для меня)
было написано выше. Ниже я расскажу о некоторых полезных привычках,
которые выработал за все время работы с Max.</p>

<h3>Research then use!</h3>

<p>
  Из работы над «Нейроинтегрумом» я вынес очень важный урок: стоит всегда разделять
  работу над проектом и работу над исследованием какой-либо технологии.
  На практике это означает, что в продакшене надо стараться не использовать
  технологию, работу которой ты примерно понимаешь, но на практике не юзал.
  Это отнимает много времени, а результат может не оправдать ожидания.
</p>
<p>
  Пример. В первой сцене спектакля рисуется генератив, похожий на трещины.
  Мне показалось, что для озвучивания этой сцены отлично подойдет икрамовский синт
  <a href="http://imtr.ircam.fr/imtr/CataRT" target="_blank">CataRT</a>.
  Синт был разобран, упакован в модуль Jamoma
  (модуль <code>/cracks</code> в первом скриншоте), к нему было сделаны мэппинги, добавлена
  поддержка многоканального звука. Но в реальных условиях патч звучал ужасно.
</p>
<p>
  В целом, работы по портированию этого синта в наш патч и по улучшению
  его звучания (иными словами, попытки допилить изначально плохую идею)
  заняли около недели. В итоге, в спектакле он все еще звучит,
  но только в очень маленькой части, в самом начале при повороте головы перформера. Сами
  же «трещины» озвучиваются более простым синтом, собранным за день вместе
  с Олегом Макаровым.
</p>
<p>
  Этому разделу вполне можно было бы дать название в духе «Не усложняй», но,
  на мой вкус, это звучит как оправдание для того, чтобы ничем не интересоваться.
  Хотя в итоге CataRT почти не юзается в спектакле, при работе с ним я обнаружил
  один интересный прием по роутингу сообщений,
  который очень сильно облегчил мне жизнь (опишу его в отдельной статье как-нибудь);
  также я разобрался, как работает garbage collector в FTM, и пришло осознание
  по некоторым тонкостям Max/MSP в целом. Так что усилия были не напрасны в любом случае :)
</p>



<h3>Naming conventions</h3>

<p>
  Названия всех файлов проекта я начинаю с какого-нибудь префикса. Например,
  в «Нейроинтегруме» был префикс <em>“n”</em>. Если имя файла составное, то
  части слова разделяю точками. Исключения составляют только «особые» патчи,
  имена которых начинаются с <em>«+»</em> — для того, чтобы их можно было легко
  найти, отсортировав список файлов по имени.

  Аналогичное правило применяю и при именовании <em>send, receive, value</em>,
  а также субпатчей.
</p>

<p>
  Думаю, стоит также отметить, что в одном из основных патчей в комментарии
  я на видном месте перечисляю все глобальные объекты <em>send, receive</em> и <em>value</em>.
  Это можно увидеть на первом скриншоте в окне <em>+sur.controller</em>.
</p>


<h3>Coloring</h3>

<p>Как бы забавно это не звучало, но одной из самых полезных привычек,
выработанных у меня является привычка раскрашивать объекты и патчкорды. Не все
подряд, конечно. Например, все <em>send/receive</em> у меня зеленые,
а <em>value</em> синие. Логика проста: <em>send/receive</em> представляют из себя
своего рода «дыры» в патче, а <em>value</em> некое состояние, которое используется
в нескольких местах, — поэтому неплохо как-то выделять эти частные случаи.
</p>

<p>
  Какой-то системы для раскрашивания проводов у меня нет: я использую это только
  для того, чтобы повысить читабельность патча при использовании
  segmented patch cords, которые вместе с тем, что делают патч чище, также
  и затрудняют его анализ.
</p>

<p><a href="/img/big-projects/4.png" target="_blank">
  <img src="/img/big-projects/4.png" />
</a></p>


<!-- ########################## -->
<!-- ########## VCS ########### -->
<!-- ########################## -->

<h3>Использование системы контроля версий с Max/MSP</h3>

<!--
Таки-да, изначально хотел рассказать одну байку из жизни, но потом передумал.
Пусть этот недописанный абзац будет пасхалкой для тех, кто читает исходный код.

<p>Пожалуй, это второй по важности инструмент для меня. Был случай, когда
в Александринку приезжал какой-то министр, и мы все <strong>усиленно работали</strong>.
Так как времени было мало, то я сделал патч, использующий кучу объектов
<em>random</em>. Меня удовлетворяло звучание, но совершенно не нравилось, что
используется куча простейших объектов (<em>[+], [==]</em> и т.д.) — решил
переделать все с использованием <em>expr</em> и <em>if</em>, чтобы сделать
патч чуточку потише. В результате, через пол часа осуществил задуманное,
но патч звучал иначе. Я был на 90% уверен, что повторил все вероятности идентично.
Видимо, не учел где-то порядок сообщений. Надо было возвращаться на предыдущую версию
</p> -->

<p>В нашей команде в качестве VCS используется Mercurial. На вопрос о том,
    почему не выбрали Git, отвечу просто: так сложилось. Вернее, так сложилось,
    что при выборе инструментов со мной никто не стал спорить на тему
    “Hg vs. Git”, — выбор был чисто субъективным.</p>

<p>О том, как правильно работать с VCS написано много статей
    (<a href="http://habrahabr.ru/post/123111/" target="_blank">рекомендую</a>).
    В целом, все подобные советы применимы и к проектам Max/MSP, поэтому в
    этой части я просто опишу, как делаю сам.</p>

<p>При работе с репозиторием я использую традиционный подход. В основной ветке
    у меня лежит 100% работающий код, который можно всегда запустить и показать
    кому-нибудь. Для работы над отдельными сценами спектакля или специфичными
    вещами (например, каким-нибудь сложным синтом) создается отдельная ветка,
    которая по завершении работы сливается с основной.</p>

<p>Все довольно стандартно, но есть одно «но». Патчи Max/MSP — это
    <em>.json</em> файлы, в которых описываются связи между объектами.
    Можно определенно понять некоторые вещи, открыв их текстовым редактором,
    однако, как правило, какой-то ценной информации, из которой можно что-то
    сказать о структуре патча, вынести из этого не получится. Если в случае с
    текстовыми языками программирования команда <code>hg diff</code> дает
    адекватное представление об изменениях в коде, то с максом такой фокус не
    пройдет. Смотрите сами:</p>

<div class="section-container accordion" data-section="accordion">
  <section>
    <p class="title" data-section-title><a href="#">Вывод <code>hg diff</code></a></p>
    <div class="content" data-section-content>
      <p><code>

		diff -r 536fb31332c6 misc/4sins.maxpat <br />
		--- a/misc/4sins.maxpat	Fri Mar 21 21:10:27 2014 +0400 <br />
		+++ b/misc/4sins.maxpat	Fri Mar 21 23:22:48 2014 +0400 <br />
		@@ -102,7 +102,7 @@ <br />
		 					"numoutlets" : 2, <br />
		 					"outlettype" : [ "", "" ], <br />
		 					"parameter_enable" : 0, <br />
		-					"patching_rect" : [ 186.0, 19.0, 73.0, 397.0 ], <br />
		+					"patching_rect" : [ 56.0, 19.0, 73.0, 397.0 ], <br />
		 					"setminmax" : [ 40.0, 120.0 ], <br />
		 					"size" : 4 <br />
		 				} <br />
		@@ -126,7 +126,7 @@ <br />
		 							"architecture" : "x86" <br />
		 						} <br />
		 , <br />
		-						"rect" : [ 713.0, 517.0, 640.0, 480.0 ], <br />
		+						"rect" : [ 306.0, 101.0, 640.0, 480.0 ], <br />
		 						"bglocked" : 0, <br />
		 						"openinpresentation" : 0, <br />
		 						"default_fontsize" : 9.0, <br />
		@@ -147,6 +147,29 @@ <br />
		 						"tags" : "", <br />
		 						"boxes" : [ 							{ <br />
		 								"box" : 								{ <br />
		+									"comment" : "", <br />
		+									"id" : "obj-9", <br />
		+									"maxclass" : "outlet", <br />
		+									"numinlets" : 1, <br />
		+									"numoutlets" : 0, <br />
		+									"patching_rect" : [ 256.0, 339.0, 25.0, 25.0 ], <br />
		+									"presentation_rect" : [ 256.0, 335.0, 0.0, 0.0 ] <br />
		+								} <br />
		+ <br />
		+							} <br />
		+, 							{ <br />
		+								"box" : 								{ <br />
		+									"comment" : "", <br />
		+									"id" : "obj-6", <br />
		+									"maxclass" : "outlet", <br />
		+									"numinlets" : 1, <br />
		+									"numoutlets" : 0, <br />
		+									"patching_rect" : [ 141.0, 339.0, 25.0, 25.0 ] <br />
		+								} <br />
		+ <br />
		+							} <br />
		+, 							{ <br />
		+								"box" : 								{ <br />
		 									"fontname" : "Arial", <br />
		 									"fontsize" : 9.0, <br />
		 									"id" : "obj-10", <br />
		@@ -241,8 +264,7 @@ <br />
		 									"numinlets" : 2, <br />
		 									"numoutlets" : 1, <br />
		 									"outlettype" : [ "signal" ], <br />
		-									"patching_rect" : [ 229.0, 176.0, 32.5, 17.0 ], <br />
		-									"presentation_rect" : [ 229.0, 174.0, 0.0, 0.0 ], <br />
		+									"patching_rect" : [ 294.0, 210.0, 32.5, 17.0 ], <br />
		 									"text" : "*~ 0." <br />
		 								} <br />
		  <br />
		@@ -256,8 +278,7 @@ <br />
		 									"numinlets" : 2, <br />
		 									"numoutlets" : 1, <br />
		 									"outlettype" : [ "signal" ], <br />
		-									"patching_rect" : [ 188.25, 176.0, 32.5, 17.0 ], <br />
		-									"presentation_rect" : [ 188.25, 174.0, 0.0, 0.0 ], <br />
		+									"patching_rect" : [ 180.25, 254.0, 32.5, 17.0 ], <br />
		 									"text" : "*~ 0." <br />
		 								} <br />
		  <br />
		@@ -272,7 +293,6 @@ <br />
		 									"numoutlets" : 1, <br />
		 									"outlettype" : [ "signal" ], <br />
		 									"patching_rect" : [ 126.0, 176.0, 32.5, 17.0 ], <br />
		-									"presentation_rect" : [ 126.25, 176.0, 0.0, 0.0 ], <br />
		 									"text" : "*~ 0." <br />
		 								} <br />
		  <br />
		@@ -399,17 +419,6 @@ <br />
		 , 							{ <br />
		 								"box" : 								{ <br />
		 									"comment" : "", <br />
		-									"id" : "obj-56", <br />
		-									"maxclass" : "outlet", <br />
		-									"numinlets" : 1, <br />
		-									"numoutlets" : 0, <br />
		-									"patching_rect" : [ 126.0, 238.0, 25.0, 25.0 ] <br />
		-								} <br />
		- <br />
		-							} <br />
		-, 							{ <br />
		-								"box" : 								{ <br />
		-									"comment" : "", <br />
		 									"id" : "obj-70", <br />
		 									"maxclass" : "outlet", <br />
		 									"numinlets" : 1, <br />
		@@ -418,17 +427,6 @@ <br />
		 								} <br />
		  <br />
		 							} <br />
		-, 							{ <br />
		-								"box" : 								{ <br />
		-									"comment" : "", <br />
		-									"id" : "obj-87", <br />
		-									"maxclass" : "outlet", <br />
		-									"numinlets" : 1, <br />
		-									"numoutlets" : 0, <br />
		-									"patching_rect" : [ 224.0, 238.0, 25.0, 25.0 ] <br />
		-								} <br />
		- <br />
		-							} <br />
		  ], <br />
		 						"lines" : [ 							{ <br />
		 								"patchline" : 								{ <br />
		@@ -532,7 +530,7 @@ <br />
		 							} <br />
		 , 							{ <br />
		 								"patchline" : 								{ <br />
		-									"destination" : [ "obj-56", 0 ], <br />
		+									"destination" : [ "obj-6", 0 ], <br />
		 									"disabled" : 0, <br />
		 									"hidden" : 0, <br />
		 									"source" : [ "obj-2", 0 ] <br />
		@@ -559,7 +557,7 @@ <br />
		 							} <br />
		 , 							{ <br />
		 								"patchline" : 								{ <br />
		-									"destination" : [ "obj-87", 0 ], <br />
		+									"destination" : [ "obj-9", 0 ], <br />
		 									"disabled" : 0, <br />
		 									"hidden" : 0, <br />
		 									"source" : [ "obj-4", 0 ] <br />
		@@ -720,15 +718,6 @@ <br />
		 					"destination" : [ "obj-2", 0 ], <br />
		 					"disabled" : 0, <br />
		 					"hidden" : 0, <br />
		-					"source" : [ "obj-91", 1 ] <br />
		-				} <br />
		- <br />
		-			} <br />
		-, 			{ <br />
		-				"patchline" : 				{ <br />
		-					"destination" : [ "obj-2", 0 ], <br />
		-					"disabled" : 0, <br />
		-					"hidden" : 0, <br />
		 					"source" : [ "obj-91", 0 ] <br />
		 				} <br />
		  <br />
		diff -r 536fb31332c6 misc/test.midi.maxpat <br />
		--- a/misc/test.midi.maxpat	Fri Mar 21 21:10:27 2014 +0400 <br />
		+++ b/misc/test.midi.maxpat	Fri Mar 21 23:22:48 2014 +0400 <br />
		@@ -31,14 +31,26 @@ <br />
		 				"box" : 				{ <br />
		 					"fontname" : "Arial", <br />
		 					"fontsize" : 12.0, <br />
		+					"id" : "obj-2", <br />
		+					"maxclass" : "newobj", <br />
		+					"numinlets" : 1, <br />
		+					"numoutlets" : 0, <br />
		+					"patching_rect" : [ 87.0, 190.0, 61.0, 20.0 ], <br />
		+					"text" : "print AAA" <br />
		+				} <br />
		+ <br />
		+			} <br />
		+, 			{ <br />
		+				"box" : 				{ <br />
		+					"fontname" : "Arial", <br />
		+					"fontsize" : 12.0, <br />
		 					"id" : "obj-4", <br />
		 					"maxclass" : "message", <br />
		 					"numinlets" : 2, <br />
		 					"numoutlets" : 1, <br />
		 					"outlettype" : [ "" ], <br />
		-					"patching_rect" : [ 88.0, 74.0, 130.0, 18.0 ], <br />
		-					"presentation_rect" : [ 348.0, 162.0, 0.0, 0.0 ], <br />
		-					"text" : "/makenote 65 100 300" <br />
		+					"patching_rect" : [ 128.0, 64.0, 134.0, 18.0 ], <br />
		+					"text" : "/makenote 65 1111 300" <br />
		 				} <br />
		  <br />
		 			} <br />
		@@ -65,14 +77,23 @@ <br />
		 					"numinlets" : 1, <br />
		 					"numoutlets" : 1, <br />
		 					"outlettype" : [ "" ], <br />
		-					"patching_rect" : [ 37.0, 103.0, 150.0, 70.0 ], <br />
		-					"presentation_rect" : [ 0.0, 0.0, 150.0, 70.0 ] <br />
		+					"patching_rect" : [ 37.0, 147.0, 150.0, 35.0 ], <br />
		+					"presentation_rect" : [ 0.0, 0.0, 150.0, 35.0 ] <br />
		 				} <br />
		  <br />
		 			} <br />
		  ], <br />
		 		"lines" : [ 			{ <br />
		 				"patchline" : 				{ <br />
		+					"destination" : [ "obj-2", 0 ], <br />
		+					"disabled" : 0, <br />
		+					"hidden" : 0, <br />
		+					"source" : [ "obj-1", 0 ] <br />
		+				} <br />
		+ <br />
		+			} <br />
		+, 			{ <br />
		+				"patchline" : 				{ <br />
		 					"destination" : [ "obj-1", 0 ], <br />
		 					"disabled" : 0, <br />
		 					"hidden" : 0, <br />
		@@ -83,7 +104,7 @@ <br />
		  ], <br />
		 		"dependency_cache" : [ 			{ <br />
		 				"name" : "n.midi.maxpat", <br />
		-				"bootpath" : "/Applications/Max 6.1/packages/ni-maxmsp/patchers", <br />
		+				"bootpath" : "/Applications/Max 6.1/packages/neurointegrum-maxmsp/patchers", <br />
		 				"patcherrelativepath" : "../patchers", <br />
		 				"type" : "JSON", <br />
		 				"implicit" : 1 <br />
		@@ -123,6 +144,10 @@ <br />
		 				"name" : "jcom.message.mxo", <br />
		 				"type" : "iLaX" <br />
		 			} <br />
		+, 			{ <br />
		+				"name" : "jcom.return.mxo", <br />
		+				"type" : "iLaX" <br />
		+			} <br />
		  ] <br />
		 	} <br />
		  <br />


      </code></p>
    </div>
</div>

<p>Ужас, не правда ли? А ведь я внес совсем небольшие изменения в пару патчей:
    поменял расположение, добавил/удалил несколько объектов.</p>

<p>Все бы ничего, но эта особенность создает очень много головной боли при
    слиянии веток, если есть конфликты. Во-первых, нельзя адекватно оценить
    изменения (и, соответственно, принять решение о том, какой кусок кода
    выбрать), а, во-вторых, может сработать автоматическая попытка разрешить
    конфликт, зачастую приводящая к странным нежеланным изменениям в патче
    (особенно в субпатчах) и последующему долгому и непродуктивному поиску
    причин некорректной работы.</p>

<p>Набив некоторое количество шишек, изрядно нагадив в истории коммитов, был
    найден идеальный вариант решения этой проблемы: полностью отказаться от
    автоматического разрешения конфликтов. В моем случае процесс мержа обычно
    является слиянием изменений в default-ветку, поэтому логично предположить,
    что изменения главной ветке де-факто устаревшие, и их можно игнорировать при
    возникновении конфликта. Как раз для такого случая в <em>Hg</em> имеется
    встроенный <em>mergetool</em> под названием
    <a href="http://www.selenic.com/hg/help/merge-tools"
       target="_blank">internal:other</a>, который в конфликтной ситуации
    просто выбирает версию не из рабочей копии.</p>

<p>Лучше покажу пример. Вот так, находясь в ветке <em>default</em>, я сливаю в
    нее изменения из ветки <em>scene_2:</em>
    <code>hg merge --tool=internal:other scene_2</code>.</p>

<p>С мержами разобрались. Двигаемся дальше.</p>

<p>У меня есть определенная система комментирования коммитов:
<br />
<code>[fix] n.breathing now has central speaker fade parameter [+] CUE scene for
    fading breathing with noise </code>
</p>

<p>В каждом комменте я стараюсь перечислить сделанные изменения. Перед каждым
    изменением в квадратных скобках ставлю тэг с очевидным смыслом
    (<strong>[+]</strong>, <strong>[-]</strong>, <strong>[*]</strong>,
    <strong>[fix]</strong>, <strong>[merge]</strong>), после чего небольшой
    текст. Это именно то, что позволяет в дальнейшем копаться в истории, и
    оперативно откатывать изменения предыдущих коммитов.</p>

<p>Очень забавно прослеживать, как меняется текст коммитов при приближении
    дедлайна. Для примера, сравните следующие комментарии с предыдущим:

<br />
<code>[all done?]</code>
<br />
<code>[lol]</code>
<br />
<code>[...]</code>
<br />

и так далее :)
</p>

<p>Редко какой проект Max/MSP обходится без медиа-файлов. Однако, Mercurial
    (да и Git тоже) не любит массивные бинарные файлы — в больших по объему
    проектах с множеством таких файлов операции, типа <em>pull</em>,
    <em>push</em> и <em>clone</em>, могут выполняться по несколько минут, а то и
    вовсе не закончиться, сославшись на недостаток оперативной памяти на
    сервере, где крутится <em>VCS</em>. Иными словами, тречить бинарные файлы в
    Hg — плохая идея. Существуют
    <a href="http://mercurial.selenic.com/wiki/BigfilesExtension"
       target="_blank">способы</a> обхода этой ситуации, однако, BitBucket с
    ними не работает, а поднимать и обслуживать свой сервер — лишний геморрой,
    которым не особо хочется заниматься.</p>

<p>Мой выход из этой ситуации прост — все медиа-файлы хранятся в директории
    <em>media</em> пэкэджа с проектом, содержимое которой добавлено
    <em>.hgignore</em>. Сама же папочка время от времени синхронизируется
    с Google Drive.</p>

<p>Подытожу вышесказанное. Использовать VCS для Max/MSP проектов можно и нужно.
    Описанные выше проблемы решаются довольно просто, а ценность возможности
    откатиться в любой момент на предыдущую версию, посмотреть, как было сделано
    раньше, сложно недооценить.</p>


<h2>Zzz</h2>

<p>
  Статья вышла несколько сумбурной: в ней имеются и практические советы, и байки,
  и техническая инфа — но иначе быть и не могло, потому что опыт субъективен.
  В статье я описал, как делаю сам; надеюсь, кому-нибудь это будет полезно :)
</p>


<!-- ##################### -->
