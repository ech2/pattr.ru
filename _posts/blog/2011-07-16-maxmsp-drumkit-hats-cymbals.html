---
layout: blogpost
title:  "Синтез ударных в Max/MSP. Часть 3: железо"
date:   2011-07-16 17:55:15
categories: blog
author: "OSCII"
permalink: /drum-synthesis-in-maxmsp-hats-cymbal.html
alias: /blog/chast-3-zhelezo
---

<p>Чтобы никто не почувствовал себя неловко, сразу скажу, что под словом «железо» я имею ввиду железные элементы
  барабанной установки. В библиотеках сэмплов их можно узнать по словам <em>hat</em>, <em>cymbal</em> или даже <em>cowbell</em>...
  Без этих элементов немыслим ни один бит: если под кик мы киваем головой вниз, то хэт – это то, что заставляет
  поднимать голову вверх. В этой статье мы будем учиться их синтезировать.</p>
<p>Для начала давайте подумаем, что особенного в этих инструментах с точки зрения звука. Технически, это негармоничный
  звук, то есть его гармоники не располагаются на одном расстоянии друг от друга. Именно эта особенность придает звуку
  металлический оттенок. Имея это ввиду, приступаем к синтезу.</p>


<h2>Хэт</h2>

<p>Его очень просто синтезировать, достаточно просто подать белый шум через огибающую громкости и обрезать все низы
  фильтром. Конечно, этот звук не будет иметь металлического оттенка, но нам этого и не нужно в случае с хэтом. Скрин
  патча <em>(hat1.maxpat)</em> приведен на рисунке ниже, он очень простой, нет смысла описывать его подробно, так как
  все объекты и техники уже были разобраны в предыдущих статьях.</p>

<p><img src="https://cloud.githubusercontent.com/assets/1007225/4955679/0bb9a34a-6697-11e4-829c-a261f03d2c10.png" alt="max/msp патч hat1.maxpat первый патч"/></p>

<p>Также можно выкрутить интересный шум с помощью FM синтеза. Нам даже не потребуется собирать свой синтезатор, в максе
  уже есть готовая абстракция <strong>simpleFM~</strong>. Сделав двойной щелчок, можно посмотреть внутренности.</p>

<p><img src="https://cloud.githubusercontent.com/assets/1007225/4955684/0bdf2502-6697-11e4-9dc0-9e37e0ed550a.png"
        alt="Простой FM синтезатор, имеющийся в составе Max/MSP"/></p>

<p>Как видно, это простой двухоператорный <em>FM</em> синтезатор. С помощью левого входа задается частота основного
  осциллятора, во второй подается частота <em>модулятора</em> (<em>модулятором</em> в FM синтезе называют осциллятор,
  который модулирует частоту другого осциллятора), третий же вход отвечает за амплитуду модулятора (параметр <em>modulation
    index</em>).</p>

<p>У FM синтеза есть одна особенность: когда частота модулятора в целое число раз отличается от частоты модулируемого
  осциллятора, синтезируется гармоничный звук. Нам же такой вариант не подходит, поэтому параметру ratio будем давать
  произвольное значение. Также, чтобы сделать звук грязнее, сделаем побольше параметр <em>modulation index</em>. Ну и
  отфильтруем ненужные низкие частоты. Вот что получилось в итоге <em>(hat2.maxpat)</em>:</p>

<p><img src="https://cloud.githubusercontent.com/assets/1007225/4955682/0bc52c7e-6697-11e4-8ab8-3ea26f7ef153.png" alt="max/msp патч hat2.maxpat fm синтез хэта"/></p>

<p>Думаю, стоит объяснить, зачем здесь объекты <strong>sig~</strong>. Дело в том, что внутри синтезатора используются
  <em>MSP</em> объекты (те, что с <em>«тильдой»</em>), и чтобы они корректно работали, нужно подавать в них аудио
  сигнал. А <strong>sig~</strong> как раз-таки преобразует обычные <em>Max сообщения</em> в аудио. Конечно, многие мсп
  объекты понимают обычные сообщения, но не все, поэтому лучше сразу использовать <strong>sig~</strong>.</p>

<h2>Cymbal</h2>

<p>Этот звук синтезировать немного сложнее, так как он имеет яркий металлический оттенок и заметную шумовую
  составляющую. Легче всего сделать его с помощью <em>кольцевой модуляции</em> <em>(ring modulation)</em>. Не смотря на
  такое умное название, ее суть очень проста для понимания: она заключается в перемножении двух сигналов между собой.
  Без лишней воды, привожу скрин патча <em>(cymb1.maxpat)</em>:</p>

<p><img src="https://cloud.githubusercontent.com/assets/1007225/4955683/0bca4ae2-6697-11e4-853c-b90ab357a5a7.png" alt="max/msp патч cymb1.maxpat rm синтез cymbal"/>
</p>

<p>Здесь есть один неизвестный объект – <strong>clip~</strong>. Его функция – ограничить сигнал по заданному диапазону,
  проще говоря, он обрезает все, что выше и ниже этого диапазона. Принцип работы показан на следующем рисунке. Слева
  показан исходный сигнал, справа – пропущенный через <strong>clip~</strong>.</p>

<p><img src="https://cloud.githubusercontent.com/assets/1007225/4955680/0bbd04ae-6697-11e4-9667-4839363008ce.png" alt="Принцип работы Max/MSP объекта clip~"/></p>

<p>Сам объект может иметь два аргумента: первый задает нижний предел, а второй – верхний. Также эти пределы можно
  менять, подавая сигнал или сообщения во второй или третий входы, соответственно для нижнего и верхнего пределов.</p>

<p>Также можно синтезировать симбалы с помощью <em>FM </em>синтеза. Посмотрите на следующий патч:</p>

<p><img src="https://cloud.githubusercontent.com/assets/1007225/4955681/0bc342d8-6697-11e4-9054-427b5152cd2f.png" alt="max/msp патч cymb2.maxpat fm синтез cymbal"/>
</p>

<p>Как можно заметить, в этом патче создана огибающая для для параметра <em>modulation index</em>. Она позволяет
  изменять тембр звука по времени.</p>
<p>Также здесь присутствует еще незнакомые нам объекты <strong>tapin~</strong> и <strong>tapout~</strong>. Два этих
  объекта реализуют линию задержки, они являются аналогами пюрдатовских объектов <strong>delwrite~</strong> и <strong>vd~</strong>,
  которые были рассмотрены в статье о гранулярном синтезе. <strong>tapin~</strong> записывает сигнал в линию задержки,
  <strong>tapout~</strong> считывает его оттуда. Каждому объекту должен быть задан аргумент. В случае с
  <strong>tapin~</strong> он определяет размер буфера дилей линии, под который будет выделяться память компьютера. Этот
  параметр нельзя модулировать. Аргумент <strong>tapout~</strong> задает время задержки, его уже можно изменять с
  помощью сигнала или же обычных сообщений, которые нужно подавать в единственный вход. Обратите внимание, что время
  задержки не может превышать размер буфера, заданного в <strong>tapin~</strong>. Кстати, вы наверняка заметили, что два
  этих объекта связаны проводом. Он служит для того, чтобы дать знать объекту <strong>tapout~</strong>, из какого точно
  буфера <strong>tapin~</strong> нужно считывать сигнал, по самому же проводу ничего не передается.</p>

<p>Также в этой дилей линии реализована обратная связь – сигнал после выхода подается опять в <strong>tapin~</strong>,
  только перед этим умножается на <em>0.8</em>. Если мы не уменьшим амплитуду сигнала в обратной связи, это приведет к
  бесконечной задержке и перегрузке аудио.
  Что касается звука, то его стоило бы немного эквализировать, убрать некоторые едкие частоты.</p>

<h2>Напоследок</h2>

<p>Синтезировать железные тарелки нелегко – надо хорошенько помучиться, подбирая параметры синтезаторов, чтобы заставить
  их звучать «как надо». Но думаю, раз уж решились работать с максом, для вас это скорее кайф.</p>

<p>Также очень полезно читать различные книги и статьи, посвященные синтезу. Есть очень хороший труд <em>Advanced
  Programming Techniques for Modular Synthesizers</em> за авторством <em>James J. Clark</em>. В ней описаны практически
  все виды синтеза, а также некоторые обработки, настоятельно советую почитать. Хотя примеры в ней созданы для <em>Nord
    Modular</em>, не составит большого труда реализовать их в максе. Лично я оттуда узнал о снейре, практически
  полностью повторив его алгоритм в предыдущей статье.</p>
