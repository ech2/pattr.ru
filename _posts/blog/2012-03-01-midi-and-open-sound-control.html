---
layout:     blogpost
title:      "MIDI и OSC - основные протоколы взаимодействия музыкальных приложений"
date:       2012-03-01 19:13:26
categories: blog
author:     "OSCII"
permalink:  /midi-and-open-sound-control.html
alias:      /blog/midi-i-osc-osnovnye-protokoly-vzaimodeystviya-muzykalnyh-prilozheniy
---

<h2>Часть 1. MIDI</h2>
<p><em>MIDI (Musical Instrument Digital
  Interface)</em> - это стандарт обмена данными между цифровыми музыкальными инструментам. Он позволяет обмениваться такой информацией, как номер ноты, скорость нажатия, таймкод и др.
<em>MIDI </em>поддерживает большинство выпускаемых музыкальных девайсов, исключения составляют многие модули модульных систем (например, Eurorack), а также такие специфичные вещи, как Monome.</p>

<h3>1 Предпосылки</h3>

<p>Необходимость в таком стандарте возникла примерно к концу 70-х годов. В то время синтезаторы управлялись напряжением с помощью интерфейса
<em>CV/Gate</em>. Существовало несколько его видов, однако, наибольшую популярность получил вариант, предложенный фирмой
<em>Roland</em>: в нем при увеличении напряжения на <em>1
  В</em>, частота генерируемого тона увеличивалась на одну октаву. Главным недостатком такого интерфейса является то, что с помощью него можно управлять только одним голосом полифонии. Для извлечения дополнительной ноты нужно добавлять еще один интерфейс
<em>CV/Gate</em>. Кроме того, таким способом передается только сам факт нажатия клавиши и ее высота, чего однозначно мало для выразительной игры.</p>

<p>Другим недостатком синтезаторов того времени была сложность настройки. Для каждого нового звука музыкантам приходилось настраивать инструмент заново, что было очень не удобно на живых выступлениях. На концертах тех времен часто можно было увидеть целые стеллажи из синтезаторов - так музыканты выходили из ситуации. Со временем в инструменты были встроены мини-компьютеры, с помощью которых можно было сохранять положения ручек в пресеты.
Однако, есть еще один момент, который оказал большое влияние на разработку <em>MIDI</em>.</p>

<p>Несомненно, у каждого синтезатора свой характер звучания, каждый из них был силен в определенных типах звуков. Поэтому многие музыканты того времени практиковали игру сразу на двух инструментах, как бы используя лучшее из разных моделей. Наслоение звуков из различных синтезаторов стало исполнительским приемом, визитной карточкой многих музыкантов. [1]</p>

<h3>2 История появления</h3>

<p>К началу 80-х большинство производителей осознали необходимость создания единого интерфейса. Задача стояла такая: разработать стандарт передачи действий исполнителя в цифровой форме между всеми типами электромузыкальных инструментов. [1]</p>

<p>Не будем детально углубляться в историю, (хотя она и очень интересна, о ней можно прочитать в [1]), приведем несколько основных дат:
<ul>
  <li>Июнь 1981 - на выставке <em>NAMM</em> произошел первый разговор на тему единого интерфейса между главами <em>Sequential
    Circuits</em>, <em>Roland и Oberheim</em>.
  </li>
  <li>Осень 1981 - первая версия интерфейса под названием <em>UMI (Universal Musical Interface)</em>.</li>
  <li>Июнь 1982 - на выставке <em>NAMM</em> были представлены плоды международной разработки. Ввиду возможных
    юридических проблем от названия <em>UMI</em> пришлось отказаться в пользу <em>MIDI</em>.
  </li>
  <li>Октябрь 1982 - закончена предварительная спецификация MIDI.</li>
  <li>Декабрь 1982 - выпушен первый синтезатор, оборудованный MIDI-интерфейсом - <em>Sequencial Circuits Prophet
    600</em>.
  </li>
  <li>1983 - сформированы комитет по MIDI-стандартам <em>(JMSC)</em>, международная группа пользователей MIDI
    <em>(IMUG)</em>, выпущена спецификация <em>MIDI 1.0</em>.
  </li>
  <li>1984 - сформирована ассоциация MIDI-производителей <em>(MMA)</em>.</li>
</ul>
</p>

<h3>3 Основы</h3>

<p><em>MIDI</em> - это протокол последовательной передачи данных между главным и подчиненным устройством. Главное устройство генерирует сообщения и отправляет их подчиненному устройству, который выполняет полученные команды. Последовательный - значит информация передается по одному биту, бит за битом. Отсюда следует невозможность передачи нескольких сообщений одновременно.</p>

<p>Сам протокол состоит из трех частей [1]: спецификация формата данных, аппаратная спецификация интерфейса и спецификация хранения данных. В данной статье будет идти речь только о первой части.
<em>MIDI</em> сообщения делятся на два типа: сообщения канала (channel messages) и системные сообщения (system messages). Первые управляют звукообразованием, а вторые выполняют служебные функции, например, синхронизация.</p>

<p><img src="https://cloud.githubusercontent.com/assets/1007225/4956138/1a52e53a-669a-11e4-95f5-8698e23e0f66.png" alt="Типы MIDI-сообщений."/></p>

<p>Сообщение обычно состоит из двух или трех байт. Первый байт называется статус байтом. В нем задается тип сообщения и номер канала, к которому оно относится. Все последующие байты называются байтами данных. Статус-байт всегда начинается с единицы, а байт-данных с нуля - таким образом система их различает. Получается, что для MIDI информации остается только 7 бит, с помощью которых можно закодировать целые числа от 0 до 127, - вот откуда берется это "знаменитое" ограничение на количество нот и значения контроллеров.</p>

<p><img src="https://cloud.githubusercontent.com/assets/1007225/4956140/1a597a30-669a-11e4-9257-896a6000494d.png" alt="Структура MIDI-сообщения."/></p>

<p>Как видно из рисунка, информации о типе сообщений отводится всего 3 бита, в которых можно закодировать только 8 чисел. 7 из них отведены под наиболее часто используемые команды, а последнее используется для системных сообщений. Когда передается системное сообщение, последние 4 бита статус байта (в которых обычно передается номер канала) определяют тип системного сообщения.</p>

<p><strong>Табл. 1. Сообщения канала.</strong>
<table>
  <thead>
    <tr>
      <td><strong>Сообщение</strong></td>
      <td><strong>Статус-байт</strong></td>
      <td><strong>Байт данных 1</strong></td>
      <td><strong>Байт данных 2</strong></td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Note Off</td>
      <td>1000nnnn</td>
      <td>Номер ноты</td>
      <td>Velocity</td>
    </tr>
    <tr>
      <td>Note On</td>
      <td>1001nnnn</td>
      <td>Номер ноты</td>
      <td>Velocity</td>
    </tr>
    <tr>
      <td>Polyphonic Key Pressue</td>
      <td>1010nnnn</td>
      <td>Номер ноты</td>
      <td>Давление</td>
    </tr>
    <tr>
      <td>Control Change</td>
      <td>1011nnnn</td>
      <td>Номер контроллера</td>
      <td>Значение</td>
    </tr>
    <tr>
      <td>Program Change</td>
      <td>1100nnnn</td>
      <td>Номер программы</td>
      <td>-</td>
    </tr>
    <tr>
      <td>Channel Pressure</td>
      <td>1101nnnn</td>
      <td>Давление</td>
      <td>-</td>
    </tr>
    <tr>
      <td>Pitch Wheel Change Change</td>
      <td>1110nnnn</td>
      <td>Номер программы</td>
      <td>-</td>
    </tr>
    <tr>
      <td>Системные сообщения</td>
      <td>1100nnnn</td>
      <td>...</td>
      <td>...</td>
    </tr>
  </tbody>
</table></p>

<p><strong>Табл. 2. Системные сообщения.</strong>
<table>
  <thead>
    <tr>
      <td><strong>Сообщение</strong></td>
      <td><strong>Статус-байт</strong></td>
      <td><strong>Байт данных 1</strong></td>
      <td><strong>Байт данных 2</strong></td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>System Exclusive (SysEx)</strong></td>
    </tr>
    <tr>
      <td>System Exclusive</td>
      <td>11110000</td>
      <td>ID</td>
      <td>...</td>
    </tr>
    <tr>
      <td><strong>System Common</strong></td>
    </tr>
    <tr>
      <td>MTC Quater Frame</td>
      <td>11110001</td>
      <td>Тайм-код</td>
      <td>-</td>
    </tr>
    <tr>
      <td>Song Position Pointer</td>
      <td>11110010</td>
      <td>LSB</td>
      <td>MSB</td>
    </tr>
    <tr>
      <td>Song Select</td>
      <td>11110011</td>
      <td>Номер песни</td>
      <td>-</td>
    </tr>
    <tr>
      <td>Tune Request</td>
      <td>11110110</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td>End Of Exclusive (EOX)</td>
      <td>11110111</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td><strong>Real Time</strong></td>
    </tr>
    <tr>
      <td>Timing Clock</td>
      <td>11111000 (248)</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td>Start</td>
      <td>11111010 (250)</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td>Continue</td>
      <td>11111011 (251)</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td>Stop</td>
      <td>11111100 (248)</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td>Active Sensing</td>
      <td>11111110</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td>System Reset</td>
      <td>11111111</td>
      <td>-</td>
      <td>-</td>
    </tr>
  </tbody>
</table>
</p>

<h3>4 Недостатки</h3>

<p><em>MIDI</em> разрабатывался, как доступный и практичный стандарт для передачи жестов исполнителя между любыми MIDI-устройствами [2]. Не в последнюю очредь благодаря своей легковесности он и получил такое распространение. Что ни говори, со своим предназначением он справляется прекрасно, и это подтверждается временем.</p>

<p>Итак, наверное, самый известный недостаток - ограничение значений контроллеров на 128 значений. Конечно, есть возможность передавать их с помощью двух байтов данных (что дает
<em>16 384</em> возможных значений), но для этого надо передать три сообщения Control Change, что очень сильно загрузит протокол, так как данные по нему передаются со скоростью
<em>31 250 бит/с</em>. Это очень мало. Для сравнения, 12-нотный аккорд передастся примерно за <em>10
  мс</em>. И это без других сообщений, например <em>Clock</em> и
<em>CC</em>. В реальном перфомансе, когда одновременно передается много различных параметров, могут возникнуть проблемы с синхронизацией.</p>

<h2>Часть 2. Open Sound Contol</h2>

<p>"Open Sound Control - это новый, оптимизированный для современных сетевых технологий протокол для взаимодействия компьютеров, звуковых синтезаторов и других мультимедиа устройств" - так был представлен
<em>OSC</em> на международной конференции по компьютерной музыке в 1997 году [3].
<em>OSC</em> не является протоколом в том виде, каким является
<em>MIDI</em>, так как он не описывает требований к аппаратному обеспечиванию - спецификации описывают лишь формат передачи данных. В этом плане
<em>OSC</em> больше схож с <em>XML</em> или <em>JSON</em>, нежели с <em>MIDI</em> [8].</p>

<p>Пока оставим технические подробности и начнем с самого начала, с истории.</p>

<h3>1 История, области применения</h3>

<p><em>Open Sound
  Control</em> был создан в 1997 году Мэттью Райтом (Matthew Wright) и Эдрианом Фридом (Adrian Freed) в Университете Калифорнии в центре новой музыки и аудио технологий
<em>(CNMAT - Center of New Music and Audio
  Technologies)</em>. Разработчики хотели использовать высокоскоростные сетевые технологии в интерактивной компьютерной музыке [4].
<em>OSC</em> не важно, по какому протоколу передаваться, так как он представляет собой всего лишь формат данных (binary message format), хотя большинство реализаций используют
<em>TCP/IP</em> или <em>UDP</em>. Другой причиной создания было то, что
<em>MIDI</em> с его нотами, каналами и контроллерами логично не подходил к разрабатывающемуся в то время синтезатору<em>CAST
  (CNMAT Additive Synthesis Tools)</em>, оно и понятно, ведь
<em>MIDI</em> - это клавишно-ориентированный протокол, который разрабатывался для управления одним синтезатором с другого [1].</p>

<p>Слово "Open" в названии означает, что <em>OSC</em> не предопределяет, какие сообщения должны использоваться для определенных параметров - это решается разработчиком конкретного девайса. Кроме того, это слово имеет и другое значение: протокол открыт, его спецификации находятся на официальном сайте, где можно скачать исходники.</p>

<p>Небольшой (и не полный) список программ, использующих <em>Open Sound Control</em>:
<ul>
  <li>Языки программирования: C/C++, Java, Php, Python, Ruby.</li>
  <li>Среды визуального программирования и синтеза: Bidule, Chuck, Common Music CPS, Intakt, Max/MSP, Open Sound World,
    Pd, SuperCollider, Reaktor, VVVV.
  </li>
  <li>Устройства для работы с сенсорами: EtherSense, Gluion, IpSonLab Kroonde, Lemur, Smart, Controller, Teabox,
    Toaster.
  </li>
  <li>Другие программы: EyesWeb, Picker, SonART, SpinOSC.</li>
</ul></p>

<h3>2 Особенности</h3>

<p><ul>
  <li>Позволяет использовать любые протоколы передачи данных (самые распространенные - <em>TCP/IP</em> и <em>UDP</em>).
  </li>
  <li><em>OSC</em> позволяет задавать интуитивные адреса для параметров. Например, если потребуется задать громкость,
    равной 100 третьего канала микшера, сообщение может выглядеть так: <em>"/mixer/channel/4/volume 100"</em>.
  </li>
  <li>Есть возможность управления несколькими параметрами с помощью одного сообщения, используя так называемый <em>pattern
    matching</em>. К примеру, понизить до 10 громкость всех каналов микшера можно с помощью такого сообщения: <em>"/mixer/channel/*/volume
    10"</em>. Такой формат записи может быть знаком программистам и пользователям операционных систем семейства Unix.
  </li>
  <li>В одном OSC-сообщении можно передавать несколько типов данных.</li>
  <li>Тайм-тэги (time tags). Каждому сообщению присваивается временнАя метка.</li>
</ul></p>

<h3>3 Анатомия сообщений</h3>

<p><img src="https://cloud.githubusercontent.com/assets/1007225/4956139/1a575444-669a-11e4-9d94-c8397580aae9.png" alt="Анатомия OSC-сообщений."/></p>

<p>Стоит отметить, что при использовании <em>UDP</em>, сообщения не обязательно будут приходить в том порядке, в каком были переданы [6]. Допустим, были переданы сообщения:</p>

<p><code>/synth1/noteoff 54 <br /> /synth1/noteon 60</code></p>

<p>Фактически они могут прийти в обратном порядке:</p>

<p><code>/synth1/noteoff 60 <br /> /synth1/noteon 54</code></p>

<p>Это может привести к проблемам с управлением голосами в полифонии, например, в данном сообщении передается команда <em>noteoff</em>, которая выключает голос, а потом включает другую ноту. Если эти сообщения придут в обратном порядке, голос не освободится и новая нота не сможет запуститься.</p>

<p>Чтобы этого избежать, надо передавать критичные к очередности приема сообщения в одном пакете (bundle), либо использовать
<em>TCP/IP</em>, он отличается от <em>UDP</em> тем, что гарантирует корректную доставку пакетов, передавая каждый из них до тех пор, пока он не передастся в изначальном виде. Нужно иметь ввиду, что ценой такому удобству будут большие в сравнении с
<em>UDP</em> задержки, поэтому использование <em>TCP/IP</em> должно быть обосновано.</p>

<h3>4 Pattern matching</h3>

<p>Символы, которые можно использовать в адресной строке [7]:
<ul>
  <li><strong>"?"</strong> - соответствует любому одному символу.</li>
  <li><strong>"*"</strong> - соответствует последовательности из нуля или любого другого числа символов.</li>
  <li><strong>Символы в квадратных скобках</strong> (например, "[string]") - соответствует любому символу в строке. В
    квадратных скобках дефис (-) и восклицательный знак (!) имеют специальное значение:

    дефис между двумя символами означает диапазон чисел в <em>ASCII</em> последовательности (дефис в конце строки не
    имеет специального значения);

    восклицательный знак после первой квадратной скобки "переворачивает" действие символов: теперь они будут
    соответствовать всем символам, которых нет в строке (если этот знак поставить в любом другом месте, его специальное
    значение пропадет).
  </li>
  <li><strong>Конструкции типа {first,second}</strong> соответствует любой из
    <ins>последовательностей символов</ins>
    , написанных через запятую.
  </li>
</ul>
</p>

<h2>Ссылки</h2>

<p>[1] <a href="http://www.muzoborudovanie.ru/articles/midi/midi1.php" title="MIDI в деталях. Часть 1 — Основы.">Цикл
  статей о MIDI из журнала "Музыкальное оборудование"</a>.
  <br />
[2] T. Winkler "<a href="http://www.amazon.com/Composing-Interactive-Music-Techniques-Ideas/dp/0262731398"
                   title="Купить книжку на Amazon">Composing interactive music</a>" - 2001 MIT Press.
  <br />
[3]  M. Wright, and A. Freed, 1997. "<a
    href="http://cnmat.berkeley.edu/publication/open_sound_control_new_protocol_communicating_sound_synthesizers"
    title="Ссылка на публикацию">Open Sound Control: a new protocol for communicating with sound
  synthesizers.</a>" - ICMC 1997.
  <br />
[4] M. Wright "<a
    href="http://opensoundcontrol.org/publication/open-sound-control-enabling-technology-musical-networking"
    title="Ссылка на публикацию">Open Sound Control: an enabling technology for musical
  networking</a>". Organised Sound 10(3): 193–200 - 2005 Cambridge University Press.
  <br />
[5] A. Schmeder, A. Freed, D. Wessel "<a
    href="http://opensoundcontrol.org/publication/best-practices-open-sound-control" title="Ссылка на публикацию">Best
  Practices for Open Sound Control</a>" - Linux Audio Conference, 01/05/2010, Utrecht, NL, (2010).
  <br />
[6] A. Fraietta "<a href="http://nime2008.casapaganini.org/documents/Proceedings/Papers/163.pdf"
                    title="Ссылка на публикацию.">Open Sound Control: Constraints and
  Limitations</a>" - 2008 8th NIME conference.
  <br />
[7] M. Wright "<a href="http://opensoundcontrol.org/spec-1_0" title="Спецификация Open Sound Control 1.0.">The Open
  Sound Control 1.0 Specification</a>" - 2002.
  <br />
[8] A. Freed, A. Schmeder "<a
    href="http://cnmat.berkeley.edu/publication/features_and_future_open_sound_control_version_1_1_nime"
    title="Спецификация Open Sound Control 1.1.">Features and Future of Open Sound Control version 1.1 for NIME</a>" - 2009.
</p>

<p>P.S. Большое спасибо хабраюзеру <a
    href="http://habrahabr.ru/users/8bitjoey/">8bitjoey</a> за найденную критическую ошибку в статье.</p>