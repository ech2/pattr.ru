---
layout:     blogpost
title:      "Distortion / waveshaping эффекты в Max/MSP"
date:       2011-08-12 22:03:34
categories: blog
author:     "OSCII"
permalink:  /distortion-waveshaping-in-maxmsp.html
alias:      /blog/distortion-waveshaping-effekty-v-maxmsp
---

<p>
  Дисторшены используются для добавления гармоник к исходному звуку. В большинстве случаев для этого используются
  вэйвшэйперы, Я говорю &laquo;в большинствe&raquo;, потому что гармоники можно добавлять еще с помощью, например,
  кольцевой модуляции (ring modulation). Итак, суть <em>waveshaping</em>-а заключается в преобразовании сигнала с
  помощью специально подобранной передаточной функции. Звучит сложно? Вовсе нет. По сути, возведение сигнала в
  квадрат &ndash; это тоже передаточная функция. Это вся теория, которую нам нужно знать. Приступим к патчингу!</p>

<h2>
  Откуда будем брать функции?</h2>

<p>
  Не будем изобретать велосипед и возьмем функции с сайта <em>musicdsp.</em><em>org</em> &ndash; это сообщество dsp
  программистов, на котором можно найти множество готовых алгоритмов, правда, большинство из них приведены в C++ коде.
</p>

<h2>
  Первый</h2>
<p>
  Начнем с самого простого примера, доступного по
  <a href="http://www.musicdsp.org/archive.php?classid=4#43" target="_blank">ссылке</a>:
</p>

<code>
  z = M_PI * a;<br/>
  s = 1/sin(z)<br/>
  b = 1/a<br/>
  <br/>
  if (x &gt; b)<br/>
  &nbsp;&nbsp;f(x) = 1<br/>
  else<br/>
  &nbsp;&nbsp;f(x) = sin(z*x)*s
</code>
  <br />
  <br />

<p>
  Здесь переменная <strong><em>а</em></strong> &ndash; управляет степенью искажения сигнала, а входящий сигнал
  представлен в виде переменной <strong><em>x</em></strong>. Теперь реализуем это в максе:</p>

<p><img alt="Первый патч" src="https://cloud.githubusercontent.com/assets/1007225/4955897/5e5e1d82-6698-11e4-9621-11114ab2cb99.png"/></p>

<p>
  Здесь роль if выполняет конструкция из объектов <strong>&gt;~</strong>, <strong>+~</strong> и
  <strong>[</strong><strong>selector</strong><strong>~ <em>2</em>]</strong>. Объект <strong>&gt;~</strong> сравнивает
  входящий сигнал (из <strong>cycle</strong><strong>~</strong>) с переменной <em>b</em> и выводит единицу, если значение
  сигнала больше переменной <em>b</em><em>,</em> и ноль, если меньше. Единица и ноль управляют объектом
  <strong>selector</strong><strong>~</strong>, который подает на выход сигналы только одного из инлетов. Соответственно,
  когда условие <em>x</em><em> &gt; </em><em>b</em> выполняется, на выход подается 1, в ином случае, выход
  рассчитывается по формуле <em>cos</em><em>(</em><em>z</em><em> * </em><em>x</em><em>) * </em><em>s</em>. Можно
  заметить, что у нас используется функция косинуса, в то время как в оригинальной формуле синус. Дело в том, что в
  максе нет объекта для вычисления синуса, вот и приходится заменять его косинусом, разницы нет, потому что различаются
  они только начальной фазой.</p>

<h2>
  Второй</h2>
<p>
  Его можно посмотреть по <a href="http://www.musicdsp.org/archive.php?classid=4#46">ссылке</a>.</p>
<code>
  x = input in [-1..1]<br/>
  k = 2*amount/(1-amount);<br/>
  <br/>
  f(x) = (1+k)*x/(1+k*abs(x))
</code>
<br />
<br />

<p>
  Автор кода отмечает, что значение <em>amount</em> должно быть в диапазоне -1&hellip;1. Разумеется, не надо ставить
  <em>amount</em> равным 1, в этом случае будет деление на ноль. Здесь у нас входящий сигнал &ndash; <strong>x</strong>.</p>

<p><img alt="Второй патч" src="https://cloud.githubusercontent.com/assets/1007225/4955896/5e5d7076-6698-11e4-8e43-43c5f60556f7.png" /></p>
<p>
  Здесь ничего сложного нет, внимательно изучив патч и сопоставив его с формулой, можно легко разобраться, как все
  работает.</p>

<h2>Третий</h2>

<p>
  <a href="http://www.musicdsp.org/archive.php?classid=4#41">Ссылка</a> на оригинал. Код:</p>
<code>
  f(x,a) = x*(abs(x) + a)/(x^2 + (a-1)*abs(x) + 1)
</code>

<p>
  Он же в максе:</p>
  <p><img alt="Третий патч" src="https://cloud.githubusercontent.com/assets/1007225/4955899/5e65fb38-6698-11e4-8b3a-651d17898e02.png"/></p>
<p>
  Сигнал искажается при параметре <em>amount &nbsp;&gt; 1</em>. Я же заметил странный эффект (по крайней мере, на
  синусоиде) когда amount находится в диапазоне <em>-1&hellip;0</em>. Пробуйте, экспериментируйте и будет счастье! :)
</p>

<h2>
  Полиномы</h2>
<p>
  Любые нелинейные преобразования сигнала создают дополнительные гармоники, в большинстве случаев бесконечное их
  количество, &nbsp;из-за чего возникают искажения в высоких частотах ввиду алиасинга. Поэтому так важно контролировать
  добавляемые гармоники, к счастью, это очень легко делается с помощью полиномов Чебышева.</p>
<p>
  Они обладают очень важным свойством: при подаче через них гармонического сигнала с единичной амплитудой (например,
  синусоиды), мы получим тот же сигнал, только в несколько раз выше. Множитель частоты будет зависеть от порядка
  полинома.</p>
<p>
  Все полиномы имеют примерно следующий вид:</p>
<code>
  y = f(x) = d<sub>0</sub> + d<sub>1</sub>x + d<sub>2</sub>x<sup>2</sup> + d<sub>3</sub>x<sup>3</sup> + ... + d<sub>N</sub>x<sup>N</sup>;
</code>
<br />
<br />
<p>
  То есть это, по сути, многочлен. N-ый элемент определяет порядок полинома. В нашем случае каждый элемент генерирует
  определенную гармонику, после чего они все складываются. Вид каждого члена определяется по следующему рекуррентному
  соотношению:</p>
<p>
  <code>T<sub>k</sub><sub>+1</sub>(x) = 2xT<sub>k</sub>(x) &ndash; T<sub>k</sub><sub>&ndash;1</sub>(x);</code>
</p>
<p>
  В нем каждый член определяется на основе предыдущего, начинается все с нулевого, в нашем случае он равен единице, и
  первого, который равен <em>x</em>:</p>
<p>
  <code>T<sub>0</sub>(x) = 1;</code></p>
<p>
  <code>T<sub>1</sub>(x) = x;</code></p>
<p>
  Зная их, можно определить третий член:</p>
<p>
  <code>T<sub>2</sub>(x) = 2x * x – 1 = 2 x<sup>2</sup> – 1;</code></p>
<p>
  И четвертый:</p>
<p>
  <code>T<sub>3</sub>(x) = 2 x (2x<sup>2</sup> – 1) – x = 4x<sup>3</sup> – 3x;</code></p>
<p>
  Как нетрудно догадаться, второй член &ndash; первая гармоника, третий &ndash; вторая и так далее.</p>
<p>
  Еще особенность полиномов Чебышева: когда через них подаешь сигнал, с амплитудой, меньше единичной, на выходе
  получается звук с меньшей насыщенностью гармоник. Это позволяет создать параметр <em>drive</em> для дисторшена.</p>
<p>
  Итак, перейдем к практике. Требуется создать дисторшен с помощью полиномов Чебышева, который будет генерировать восемь
  гармоник, а также позволит задавать амплитуду каждой составляющей. Мы не будем для каждой гармоники искать
  передаточную функцию, вместо этого создадим небольшой сабпатч, который будет на основе двух предыдущих гармоник
  генерировать новую.</p>

  <p><img alt="Рекурсия" src="https://cloud.githubusercontent.com/assets/1007225/4955898/5e64508a-6698-11e4-9d20-96a229950dcc.png" /></p>
<p>
  В первый инлет подается предыдущая гармоник, во второй &ndash; стоящая перед предыдущей, а в третий &ndash; не
  измененный входящий сигнал. Как видно, этот субпатч просто реализует рекуррентное соотношение

  <code>T<sub>k</sub><sub>+1</sub>(x) =
  2xT<sub>k</sub>(x) – T<sub>k</sub><sub> – 1</sub>(x)</code>,
  ничего сложного нет.</p>
<p>
  Теперь из этих блоков создадим патч, позволяющий добавлять вплоть до восьмой гармоники (высокочастотный фильтр в конце
  цепочки убирает DC offset):</p>

<p><img alt="Готовый полином восьмой степени" src="https://cloud.githubusercontent.com/assets/1007225/4955895/5e551d5e-6698-11e4-9442-310553ce7e6f.png" /></p>
<p>
  Этот патч позволяет регулировать амплитуду добавляемых гармоник, это можно использовать для эмуляции аналоговых
  устройств. Так, многие ламповые дисторшены, в основном добавляют четные гармоники, нечетные в них появляются только
  при высоком входящем сигнале. Многие низкокачественные усилители могут создвать третью гармонику.
  Твердотельные &ldquo;Fuzz-Face&rdquo; дисторшены искажают сигнал несимметрично, в них явно присутствуют вторая и
  третья гармоники, а также немного четвертой и пятой гармоник. <em>Electro-Harmonix Big-Muff PI</em> искажает
  симметрично и производит&nbsp; в основном пятую и седьмую гармоники.</p>

<h2>
  Заключение</h2>

<p>
  Любые амплитудные преобразования влекут за собой неприятное последствие &ndash; алиасинг. Он появляется тогда, когда
  генерируемые гармоники превышают максимальную частоту сигнала <em>(</em><em>Niquist</em> <em>frequency</em><em>)</em>,
  которая равна половине частоты дискретизации. Для борьбы с ним используют оверсемплинг &ndash; выполнение внутреннего
  алгоритма на увеличенной в несколько раз частоте дискретизации, с последующим ее понижением при выходе сигнала из
  устройства. При использовании полиномов Чебышева можно точно узнать, во сколько раз требуется повысить частоту
  дискретизации, чтобы полностью убрать алиасинг &ndash; это определяется по самой высокой генерируемой гармоники. Когда
  же алгоритм основан на других передаточных функциях, исключить его полностью не удастся, так как обычно эти алгоритмы
  генерируют бесконечное количество гармоник, однако оверсемплинг позволяет значительно уменьшить эффект алиасинга.</p>
<p>
  Большинство вэйвшейперных vst в работе не используют формулы для преобразования сигнала, их роль выполняют таблицы
  значений. В нее заносятся значения формул в диапазоне <em>-1&hellip;1</em>. Это позволяет не проводить ресурсоемкие
  вычисления в реальном времени, а также дает возможность &laquo;рисовать&raquo; передаточные функции.</p>
<p>
  Думаю, в одной из следующих статей напишу о том, как сделать оверсемплинг и табличный вэйвшэйпинг в максе, так что
  stay tuned.</p>
<p>
  P.S. В архиве с патчами также находится патч all_in_one.maxpat, в котором представлены все алгоритмы с возможностью
  выбора алгоритма и исходного звука.</p>
